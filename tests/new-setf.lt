;;; -*- mode: lisp; package: cl.test.new-setf -*-
;;;
;;; tests/new-setf.lt
;;;

(defpackage :cl.test.new-setf)
(in-package :cl.test.new-setf)

(require "cl")
(cl::install)

(require "lisp-unit")
(use-package :lisp-unit)

(remove-all-tests)

(defconstant +unbound-value+ (gensym))

(defmacro %assert-setf (place new-value &rest more)
  (let (($old (gensym))
        ($new (gensym)))
    `(let ((,$old (handler-case
                      (multiple-value-list ,place)
                    (unbound-variable (e)
                      +unbound-value+)))
           (,$new (multiple-value-list ,new-value)))
       (unwind-protect
           (progn
             (mapc (lambda (actual expected)
                     (assert-equal expected actual :return-values ,@more))
                   (multiple-value-list (setf ,place ,new-value))
                   ,$new)
             (mapc (lambda (actual expected)
                     (assert-equal expected actual :afterward ,@more))
                   (multiple-value-list ,place)
                   ,$new))
         (if (eql ,$old +unbound-value+)
           ,(cond ((symbolp place) `(makunbound ',place))
                  ((and (consp place)
                        (eq (car place) 'values))
                   `(progn ,@(mapcar (lambda (var)
                                       `(makunbound ,var))
                               (cdr place))))
                  )
           (setf ,place (values-list ,$old)))))))

(setq foo :default)
(defun foo () nil)
(define-test new-setf-symbol
  (%assert-setf foo :value)
  (%assert-setf (get 'foo 'example) :value)
  (%assert-setf (symbol-value 'foo) :value)
  (%assert-setf (symbol-function 'foo) #'car #'foo)
  (%assert-setf (symbol-plist 'foo) '((key-0 . "value-0") (key-1 . :value-1))))

(define-test new-setf-list-1
  "car .. cddddr"
  (let ((list '((((hoge fuga) piyo) (foo bar) baz)
                ((a b) c)
                (1 2)
                3 4 5 6 7)))
    (%assert-setf (car list) :value)
    (%assert-setf (cdr list) :value)
    (%assert-setf (caar list) :value)
    (%assert-setf (cadr list) :value)
    (%assert-setf (cdar list) :value)
    (%assert-setf (cddr list) :value)
    (%assert-setf (caaar list) :value)
    (%assert-setf (caadr list) :value)
    (%assert-setf (cadar list) :value)
    (%assert-setf (caddr list) :value)
    (%assert-setf (cdaar list) :value)
    (%assert-setf (cdadr list) :value)
    (%assert-setf (cddar list) :value)
    (%assert-setf (cdddr list) :value)
    (%assert-setf (caaaar list) :value)
    (%assert-setf (caaadr list) :value)
    (%assert-setf (caadar list) :value)
    (%assert-setf (caaddr list) :value)
    (%assert-setf (cadaar list) :value)
    (%assert-setf (cadadr list) :value)
    (%assert-setf (caddar list) :value)
    (%assert-setf (cadddr list) :value)
    (%assert-setf (cdaaar list) :value)
    (%assert-setf (cdaadr list) :value)
    (%assert-setf (cdadar list) :value)
    (%assert-setf (cdaddr list) :value)
    (%assert-setf (cddaar list) :value)
    (%assert-setf (cddadr list) :value)
    (%assert-setf (cdddar list) :value)
    (%assert-setf (cddddr list) :value)
    ))

(define-test new-setf-list-2
  "first .. tenth"
  (let ((list '(0 1 2 3 4 5 6 7 8 9)))
    (%assert-setf (first list) :value)
    (%assert-setf (second list) :value)
    (%assert-setf (third list) :value)
    (%assert-setf (fourth list) :value)
    (%assert-setf (fifth list) :value)
    (%assert-setf (sixth list) :value)
    (%assert-setf (seventh list) :value)
    (%assert-setf (eighth list) :value)
    (%assert-setf (ninth list) :value)
    (%assert-setf (tenth list) :value)))

(define-test new-setf-list-3
  "other list accessors."
  (let ((list '(0 1 2 3)))
    (%assert-setf (rest list) :value)
    (dotimes (i (length list))
      (%assert-setf (nth i list) :value i))))

(define-test new-setf-array
  (let ((vector #(foo bar baz)))
    (dotimes (i (length vector))
      (%assert-setf (aref vector i) :value vector i)
      (%assert-setf (svref vector i) :value vector i)))
  (let ((avector (make-array 12 :fill-pointer 0 :adjustable t)))
    (dotimes (i (length avector))
      (%assert-setf (fill-pointer avector) i avector i)))
  (let ((array #2A((foo bar) (hoge fuga) (spam egg))))
    (multiple-value-bind (li lj)
        (values-list (array-dimensions array))
      (dotimes (i li)
        (dotimes (j lj)
          (%assert-setf (aref array i j) :value array i j))))
    (dotimes (i (array-total-size array))
      (%assert-setf (row-major-aref array i) :value array i))
    ))

(define-test new-setf-string
  (let ((string "example"))
    (dotimes (i (length string))
      (%assert-setf (char string i) #\! string i)
      (%assert-setf (schar string i) #\! string i))))

(define-test new-setf-sequence
  (let ((list '(0 1 2 3 4))
        (vector #(0 1 2 3 4)))
    (dolist (seq (list list vector))
      (dotimes (i (length seq))
        (%assert-setf (elt seq i) :value seq i)))))

(define-test new-setf-hash-table
  (let ((ht-eql (make-hash-table))
        (ht-equal (make-hash-table :test 'equal)))
    (dolist (pair '((foo . "foo")
                    (bar . "bar")
                    (baz . "baz")))
      (%assert-setf (gethash (car pair) ht-eql) (cdr pair) pair)
      (%assert-setf (gethash (cdr pair) ht-equal) (car pair) pair)
      )))

;;; NOTE: accessors defined in lisp/setf.l but not testef yet
;;; - using setter function
;;;   - default-value
;;; - using setf expander:
;;;   These accessors originally using old GET-SETF-METHOD, so you gonna redefine it
;;;   to use GET-SETF-EXPANSION instead.
;;;   - subseq
;;;   - ldb
;;;   - mask-field
;;;   - apply

;;; tests/new-setf.lt ends here.
