;;; -*- mode: lisp; package: cl.test.typecase -*-
;;;

(defpackage :cl.test.typecase)
(in-package :cl.test.typecase)

(require "cl")
(cl::install)

(require "lisp-unit")
(use-package :lisp-unit)

(remove-all-tests)



(define-test typecase

  (defun typecase-test-1 (x)
    (typecase x
      (integer :integer)
      (string :string)
      (symbol :symbol)
      (t :other)))

  (assert-eql :integer (typecase-test-1 3))
  (assert-eql :string (typecase-test-1 "foo"))
  (assert-eql :symbol (typecase-test-1 'foo))
  (assert-eql :other (typecase-test-1 '(foo bar)))


  (defun typecase-test-2 (x)
    (typecase x
      (float "a float")
      (null "a symbol, boolean false, or the empty list")
      (list "a list")
      (t (format nil "a(n) ~A" (type-of x)))))

  (assert-equal "a float" (typecase-test-2 3.2))
  (assert-equal "a symbol, boolean false, or the empty list" (typecase-test-2 nil))
  (assert-equal "a list" (typecase-test-2 '(foo bar)))
  (assert-equal "a(n) simple-string" (typecase-test-2 "foo"))
  (assert-equal "a(n) hash-table" (typecase-test-2 (make-hash-table)))

  (assert-equal :other
      (typecase 3
        (symbol :symbol)
        (list :list)
        (otherwise :other)))
  ) ; define-test typecase

(define-test etypecase

  (defun etypecase-test-1 (x)
    (etypecase x
      (integer :integer)
      (string :string)
      (symbol :symbol)))

  (assert-eql :integer (etypecase-test-1 3))
  (assert-eql :string (etypecase-test-1 "foo"))
  (assert-eql :symbol (etypecase-test-1 'foo))
  (assert-error 'type-error (etypecase-test-1 #(1 2 3)))

  (defun etypecase-test-2 (x)
    (etypecase x
      (float "a float")
      (null "a symbol, boolean false, or the empty list")
      (list "a list")))

  (assert-equal "a float" (etypecase-test-2 3.2))
  (assert-equal "a symbol, boolean false, or the empty list" (etypecase-test-2 nil))
  (assert-equal "a list" (etypecase-test-2 '(foo bar)))

  (let ((err (handler-case
                 (etypecase 3
                   (string :string) (symbol :symbol))
               (type-error (e) e))))
    (assert-true (typep err 'type-error))
    (assert-eql 3 (type-error-datum err))
    (assert-equal '(or string symbol) (type-error-expected-type err)))

  ;; etypecase allow t as type, which effectively work as otherwise-clause
  (assert-eql :other
      (etypecase 3 (string :string) (cons :cons) (t :other)))

  ) ; define-test etypecase


(define-test ctypecase

  (defun ctypecase-test-1 (x)
    (ctypecase x
      (integer :integer)
      (string :string)
      (cons :cons)))

  (assert-eql :integer (ctypecase-test-1 1))
  (assert-eql :string  (ctypecase-test-1 "foo"))
  (assert-eql :cons    (ctypecase-test-1 '(foo bar)))
  (assert-error 'type-error (ctypecase-test-1 'fred))

  (assert-true (block #1=#:ctypecase-test-2
                 (handler-bind
                     ((type-error (lambda (e)
                                    (return-from #1#
                                      (find-restart 'store-value e)))))
                   (ctypecase 33
                     (string :string)
                     (cons :cons)))))

  (let ((foo 33))
    (assert-eql :ok
        (handler-bind ((type-error
                        (lambda (e)
                          (invoke-restart (find-restart 'store-value e)
                                          "Finally!!"))))
          (ctypecase foo
            (string :ok))))
    (assert-equal foo "Finally!!"))
  )





;;; test/typecase.lt ends here.
